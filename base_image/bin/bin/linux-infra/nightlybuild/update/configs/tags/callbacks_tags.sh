# Callbacks for tag management

# Internals
TAGS_REPO_BRANCH="master"    # this should be master
TAGS_TARGET="tags"
REPO_FILE="${TAGS_TARGET}/release-branch-config.sh"

# GIT Library
source ${LIB_PATH_NIGHTLY}/libgit.sh


function do_init() {

    echo "${FUNCNAME}: info: started"

   # check mandatory vars
   echo "${FUNCNAME}: info: checking the socfpga specific variables..."
   for var in TAGS_REPO REPO_FILE TAGS_FILE TAGS_PREFIX TAGS_SUFFIX ; do
       eval tmp=\$${var}
       if [ -z ${tmp} ] ; then
           echo "${FUNCNAME}: ${var}: mandatory variable not set."
           return 2
       fi
   done

   # now clone the linux-tags repo
    echo "${FUNCNAME}: info: starting clone of ${TAGS_REPO}"
    # TODO: move origin/ to clone_git_repo
    clone_git_repo ${TAGS_REPO} origin/${TAGS_REPO_BRANCH} ${TAGS_TARGET} ${TAGS_REPO_BRANCH}
    if [ $? -ne 0 ] ; then
        echo "${FUNCNAME}: clone_git failed for tags"
        return 1
    fi

   # now check the TAGS_FILE exists
   # TODO: change to linux-infra location
   if [ ! -e ${REPO_FILE} ] ; then
       echo "${FUNCNAME}: error: ${REPO_FILE}: no such file"
       return  3
   fi

   return 0
}

#TODO: move above
CONST_INTERNAL_REPO=0
CONST_EXTERNAL_REPO=1
TMP_REPO_TARGET="blob"

function save_tags_to_file() {

   echo '# autogenerated tag list' > ${TAGS_TARGET}/${TAGS_FILE}
   while [ $# -gt 0 ] ; do
       echo $1 >> ${TAGS_TARGET}/${TAGS_FILE}
       shift 
   done

   return 0
}

function do_build() {
set -x
    declare -a all_tags

    echo "${FUNCNAME}: info: reading ${REPO_FILE}"
    source ${REPO_FILE}

    # now we do have a key variable to read: repo_list
    if [ "${repo_list}" == "" ] ; then
        echo "${FUNCNAME}: error: variable repo_list is not set!"
        return 4
    fi

    # repo_list is a comma separated list of components
    for component in $(echo ${repo_list} | sed -e 's/,/ /g') ; do
        # if all is right, component is  a variable set 
        eval list=\$${component}
        if [ "${list}" == "" ] ; then
            echo "${FUNCNAME}: error: ${component} is not set. Please check ${REPO_FILE}."
            return 5
        fi

        # let's get the component's items into an array, it will be a lot easier to
        # access data and ignore that we don't need (external URL)
        # some repos are for internal use only, so they will be marked ',,' in the 
        # release config file
        declare -a repo_items=($(echo ${list} | sed -e 's/,,/,undef,/' | sed 's/,/ /g'))
        local repo_internal_url=${repo_items[${CONST_INTERNAL_REPO}]}
        local repo_name=$(get_repo_from_url ${repo_internal_url})

        # now that we have the repo, let's go ahead and clone it
        clone_git_repo ${repo_internal_url} "master" ${TMP_REPO_TARGET}
        if [ $? -ne 0 ] ; then
            echo "${FUNCNAME}: error: could not clone ${repo_name}"
            return 6
        fi

        # now we need all branches
        # so we get rid of the two first elements...
        declare -a branches=("${repo_items[@]:2}") #makes code more readable

        cd ${TMP_REPO_TARGET}
        for branch in ${branches[@]} ; do
            echo git checkout -b ${branch} origin/${branch}
            if [ $? -ne 0 ] ; then
                echo "${FUNCNAME}: error: could not checkout ${branch} from ${repo_name}"
                return 7
            fi

            # Alan's stuff here
            tag=$(get_tag.sh -r ${repo_name} -b ${branch} -p ${TAGS_PREFIX} -s ${TAGS_SUFFIX})
            if [ $? -ne 0 -o "${tag}" == "" ] ; then
                echo "${FUNCNAME}: error: could not get tag..."
                return 8
            fi

            # now tag it
            git tag ${tag} origin/${branch}
            if [ $? -ne 0 ] ; then
                echo "${FUNCNAME}: error: failed to tag repo ${repo_name} with tag ${tag} on branch ${branch}"
                return 1
            fi

            git push origin ${tag}:refs/tags/${tag}
            if [ $? -ne 0 ] ; then
                echo "${FUNCNAME}: error: failed to push tags for repo ${repo_name}"
                return 1
            fi

            # we need to save all tags we add
            all_tags+=( "${repo_name}:${tag}" )

        done   # branches

        cd - 
        # now we clean up
        echo 'y' | rm -rI ${TMP_REPO_TARGET}
        if [ $? -ne 0 ] ; then
            echo "${FUNCNAME}: error: could not remove repo clone dir ${TMP_REPO_TARGET}"
            return 1
        fi
    done    # repos
    
    # let's dump all of tags
    save_tags_to_file ${all_tags[@]}
set +x

    return 0
}

function do_package() {

    local tag

    echo "${FUNCNAME}: info: started"
    cd ${TAGS_TARGET}
    git add ${TAGS_FILE}
    git commit -m "file update from nightly build $(date)"
    tag=$(get_tag.sh -r ${TAGS_REPO} -b ${TAGS_REPO_BRANCH} -p ${TAGS_PREFIX} -s ${TAGS_SUFFIX})
    git tag ${tag} HEAD
    git push origin ${TAGS_REPO_BRANCH} ${tag}:refs/tags/${tag}
    if [ $? -ne 0 ] ; then
        echo "${FUNCNAME}: error: could not push ${TAGS_FILE} and ${tag}"
        return 1
    fi

    tag=$(get_tag.sh -r ${TAGS_REPO} -b ${TAGS_REPO_BRANCH} -p ${TAGS_PREFIX} -s ${TAGS_SUFFIX})
    
    return 0
}

# TODO: remove
function do_tag() {

    echo "${FUNCNAME}: info: started"

}
